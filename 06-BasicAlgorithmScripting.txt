# javaScriptAlgorithmsDataStructuresFreecodecamp
## Basic Algorithm Scripting
Start:  23/08/2020
Pomodoros:  54 
Notas: 
    - "Better Comments" ; Visual Studio Code
    - Uso comentarios con colores 
    
¡---------------------------------------------------------------->  
//--------------------------------------------------------------->
*==iMAP========================================================-->

todo --Output--
//methods
document.getElementById(id)
#to access an html element
//e.g
  <html>
    <p id="edu"></p>
    <script>
      document.getElementById(edu).innerHTML = "hola";
    </script>
  </html>

document.write()
#solo para hacer tests
window.alert()
#ventanita
//En navegador -> <p>Hola</p>

//properties
innerHTML
#define the content of an HTML element

todo --boolean--
//false values
false
//falsy values
null
undefined
NaN
0
'' or "" (empty string)
//truthy (rest)
what is not falsy

//OR and AND
(a||b)
  * if a is true -> returns a
  * if a is not true -> returns b
(a && b)
  * both true -> return a
  * if both are not true -> return b

//Boolean(value) object (borrar lo que sobra)
* Boolean es un objeto de javascript que se puede usar para evaluar falsy/truthy values.
  * Devuelve false si le pasamos: 0, -0, "", false null, NaN. el resto de valores dan true/false valores boolean primitivos
//uso
console.log(Boolean("true")) // false (evalúa a false porque es un string no vacío :P)


todo --function constructora de objetos
//función 
function Person(age){
  this.age = age;
  this.getAge = function (){return 'My age is: ' + this.age}
}
//creación objeto
const edu = new Person(36);
//uso objeto 
console.log(edu.getAge()); // "My age is: 36"
console.log(edu.getAge);   // "My age is: 36"
console.log(edu.age);      // 36

todo --constructor property--
objectName.constructor
//acceder al constructor de una clase
  function Arbol(nombre){
    this.nombre = nombre;
  }
  new Arbol().constructor //function Arbol(nombre){this.nombre = nombre;}

todo --prototype property--
//Añadir una propiedad a un constructor
Person.prototype.altura = 169;

//prototype para añadir métodos a un objeto
Person.prototype.full = function(){return this.name + this.dni + this.altura };
!no se puede usar notación arrow function aquí

todo --class, getters & setters--
¡---
class
get
set
constructor
¡---
//class
class ObjectName{
  constructor(x){
    this._attribute = x;
  }
  get attribute(){
    return  this._attribute;
  }
  set temperature(y){
    this._temperature = y;
  }
}
//use
const ObjectName = new ObjectName(z); //constructor use
let temp = ObjectName.attribute; //getter use
ObjectName.attribute = value; //setter use

todo --promise--
¡---
Promise
resolve
reject
then
catch
¡---
?syntax
const makeServerRequest = new Promise((resolve,reject) =>{
    if(condition){
        resolve("Promise fulfilled");
    }else{
        reject("Promise rejected");
    }
});

makeServerRequest.then(result => {
  console.log(result);
});

ServerRequest.catch(error =>{
  console.log(error);
})
?syntax

//estados de una promesa
pending
fulfilled()
rejected()

todo --import/export--
¡---
import
export
as
from
./
¡---
//file.js both in the same directory "./"
export {function1,function2};
import {function1,function2} from './index.js';
import * as myObject from './index.js';
//default fallback
export default function(){}
import variableName from "./index.js";

todo --built in Objects--
Date()
String()
Number()
Boolean()
Array()
RegExp()
Function()


todo --variables--
const
var
let


todo --ternary conditional--
(condition) ? code-true : code-false;

todo --shorthanded ternary?
// devuelve true si se cumple la condición y devuelve false si no se cumple la condición
return (condition); 
//ejemplo borrar pronto
return arr.indexOf(elem) != -1;


todo --loops--
while(cond){}
for ([initialization]; [condition]; [final-expression]){}
do{}while(condition);
if(){}else{}else return;

todo --for...in--
? for (variable in object)
variable = cambiar de nombre según el nombre de las propiedades de object
object = objeto de cuyas propiedades se van iterando (deben ser iterables, no Symbol)
// iterando sobre un objeto
const object = {a:1, b:2}
for (let propiedad in object){
  console.log(propiedad + " vale " + object[propiedad])
}
imprime: "a vale 1" "b vale 2"
//iterando sobre un String
* el itreador "propiedad" en este caso devuelve el índice del String [borrame cuando me entiendas bien]
* para acceder 
const str = "Edu"
for (let propiedad in str){
  console.log(propiedad + " vale " + str[propiedad])
}
imprime: "0 vale E" "1 vale d" "2 vale u"



todo --object
var object = {att:value,att2:value};
{} -> object literal
.
["']
delete -> para borrar un atributo de un objeto
?delete object.att



todo --flux--
if
else if
else
switch
case
break
default

todo --estructuras if else--
if(){code}else{code}
if() 1_line_code;else{code} 
if()code;else 1_line_code;
() ? code : code;
() ? code : null;
simple_condition ? code : code;

todo --definición de funciones--  
function myFunction(){}
let/var/const = function(a,b){};
x = Function()
//arrow functions
const x = () => {}
const x = () => "value"
const x = item => item * 2;
const x = (item1, item2) => item1 * item2;
//arrow function + object property shorthand
const x = (item1, item2) => ({item1 , item2}); 

todo --spread operator--
...

todo --rest parameter--
...

todo --memory structures--
[[{}],[{}]]

todo --methods of Global Object--
Math.min()
Math.max()
? arr =[1,2,3]
?Math.max(...arr);
Math.floor()
Math.random()
Math.round()
console.log()
parseInt()
  :* parseInt("")
  :* parseInt ("", radix)


todo --methods--
¡Object.prototype¡
Object.freeze()
hasOwnProperty(propname) 
Object.freeze()
valueOf()
# devuelve el "primitive value" de un objeto
# si un objeto no tiene on valor primitivo valueOf() imprime el objeto en sí
?object.valueOf()


¡--String.prototype--¡
trim()
substr()
?string.substr(start, length);
// "Hello".substr(0,4) // "Hell"
//eduardo.substr(3) //"ardo"
charAt()
?let character = str.charAt(index)
//"Eduardo".charAt(0) // "E"
slice()
splice()
repeat()
push()
pop()
shift()
unshift()
match()
?str.match(regexp)
// hola."match"(/h/) //["h"]
concat()
toUpperCase()
toLowerCase()
split()
?str.split([separator[, limit]])
// "e d".split('') //['e', ' ', 'd']
//"e d".spli(' ') // ['e','d']



¡--Array.prototype--¡
todo --usan callback functions--
Array.of()
? Array.of(element0[, element1[, ...[, elementN]]])
//Array.of(1, 2, 3); // [1, 2, 3]
includes()
//[1,2].includes(2) --> true
//"hola".includes("h") --> true
slice()
?arr.slice([start[, end]])
// [1,2].slice()    // [1,2]
// [1,2,3].slice(1)   //  [2,3]
// [1,2].slice(0,1) //  [1]

h
concat()
#Devuelve un nuevo array con el resultado de unir otros dos arrays
#Se le pueden pasar elementos y arrays
#Se diferencia de push() entre otras cosas en que push sí que cambia el array original
//array1.concat(array1)

findIndex()
# devuelve el índice del primer elemento que satisface la función que le pasamos
# si no encuentra ninguno, devuelve -1
# si no le pasamos una función ordena en unicode, donde el 10 va delante del 2 esta función
?arr.findIndex(callback( element[, index[, array]] )[, thisArg])
//arr.findIndex( element => element >= num )
sort()
?arr.sort([compareFunction])
# sort sobreescribe el array sobre el que actúa
# La funcion debe devolver nº neg si a < b, positivo si a > b o 0 si son iguales
# Se puede abreviar a - b
// [3,6,20,6,7,5].sort((a, b) => a - b)
call()
reduce()
?arr.reduce(callback(acumulador, valorActual[, índice[, array]])[, valorInicial])
//arr.reduce(function(){},value);
map()
filter()
#crea un nuevo array con los eltos que pasan el test dado como función por argumento
find()
?arr.find(callback(element[, index[, array]])[, thisArg])
//[1,2,3,4].find( element => element > 2 )// 3


todo --otros--
indexOf()
? array.indexOf(searchElement[, fromIndex])
// ['ant','bison'].indexOf('bison')  //   1
// ['ant','bison'].indexOf('monkey') // -1


filter()
?var newArray = arr.filter(callback(currentValue[, index[, array]])[, thisArg])
//['perro','oso'].filter( word => word.length > 3 // ["perro"]

splice() 
!changes the original array
? array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
//['edu','blas','epi'].splice(1,1) // ['blas']
//['edu','blas','epi'].splice(1,2) // ['blas', 'epi']
//['edu','blas','epi'].splice(2) // ['blas', 'epi']

slice()
!make a copy
?arr.slice([start[, end]])
//['ant','bison','camel'].slice(1) //['bison', 'camel']
!ojo no incluye el elto de índice "end"
//['ant','bison','camel'].slice(0,2) //['ant','bison']
join()
?arr.join([separator])
//['a','b'].join() //"a,b"
//['a','b'].join('') //"ab"
//['a','b'].join(' ') //"a b"
reverse()
fill()
 

¡--Function.prototype--¡
¡--
call()
apply()
bind()
¡--

apply()
? apply(thisArg,[array]) -> aplica una función sobre un [array] usando como contexto thisArg
* thisArg = null
//const arr = [1,2,3];
//Math.max.apply(null,arr) //3
*con thisArg
//const arr1 = ['a','b'];
//const arr2 = [1,2,3];
//console.log(arr1); // ["a", "b", 0, 1, 2]
? liga una función a un objeto para que no se ejecute desde el ámbito global

bind()
?fun.bind(thisArg[, arg1[, arg2[, ...]]])
//ejemplo
const pepe = {
  edad: 36,
  getEdad: function(){
    return this.edad;
  }
};
//si no usamos bind
const boundedGetAge = pepe.getEdad;
console.log(boundedGetAge()); // undefined
//si usamos bind
const boundedGetAge = pepe.getEdad.bind(pepe);//36


todo --properties--
'vale para strings y para arrays (borrame cuando me entiendas bien)
.length 

todo --tipos primitivos--
undefined 
null
boolean
string
symbol
bigint
number
object 

todo --operators--
: ! -> not
= -> asignación
+ -> adición/concatenation : number/string
- -> substraction
:* -> multiplication
/ -> division
++ -> increment
-- -> decrement
% -> remainder
+= -> 
-=
:*=
/=
typeof
// typeof true // 'boolean'

todo --comparison operators--
'ojo todos los comparadores devuelven true/false --> borrar esto cuando esté asimilado.
==
=== [strict]
:!=
:!== [strict]
>
>=
<
<=


todo --escape chracters--
\"
\'
\\
\n
\r
\t
\b
\f

todo --postfix/prefix increment
++i -> prefix increment
i++ -> postfix increment
--i -> prefix decrement
i-- -> postfix decrement

todo --logical operators--
&&
||

¡ --ES6--

todo --use strict--
"use strict"

todo --destructuring assignment
const {key1,key2} = var
todo --template literals--
${}
`` -> back ticks


todo --Promise()--
const makeServerRequest = new Promise((resolve,reject) =>{
    if(condition){
        resolve("Promise fulfilled");
    }else{
        reject("Promise rejected");
    }
  
});

makeServerRequest.then(result => {
  console.log(result);
});

ServerRequest.catch(error =>{
  console.log(error);
})

//estados de una promesa
pending
fulfilled()
rejected()

todo --import/export--
//file.js both in the same directory "./"
export {function1,function2};
import {function1,function2} from './index.js';
import * as myObject from './index.js';
//default fallback
export default function(){}
import variableName from "./index.js";


todo --spread operator--
...

todo --rest parameter--
...

todo --static reference/static object
let
const
Object.freeze()
let 
"use strict"
...
// destructuring assignment
const {key1,key2} = var
// template literals
${}
`` ->template string
./ 
export
import
get
set

todo --Passing object as a function parameter--
//setup
const stats = {max: 56.78, min: -0.75};
//def normal
const half = (stats) => (stats.max + stats.min) / 2.0; 
//definition using destructuring assignment
const half = (stats) =>{
    const{max,min} = stats;
    return (max + min) / 2.0; 
} 
//definition reduced (no entire object)
const half = ({max,min}) => (max + min) / 2.0; 
}
//use
console.log(half(stats));


//normal
const getMousePosition = (x,y) => ({x: x, y: y});
//object property shorthand
const getMousePosition = (x, y) => ({x , y});

¡ --regex--
todo --RegExp Object--
?constructor
/pattern/flags
new RegExp(pattern[, flags])
RegExp(pattern[, flags])

//methods
test()
#true si el string que le pasamos como parámetro contiene el RegExp
// /a/.test("hola")   //true

//métodos y patrones
match()
test()
|
// /dog|cat|bird|fish/
/regex/i
/regex/g
/./
// /.du/
[x-y]
// /[a-z]/
[abc]
// /[oa]la/
[x-y4-7]
// /[h-s2-6]/gi
[^regex]
?negated
// ningún número y ninguna vocal
// /[^0-9^aeiou]/gi
/x+/
? 1-infinite
/xx+/
?2-infinite
/x*/
? 0-infinite
// /<.*?>/
/x?/
\W
? [^A-Za-z0-9_]
\w
? [A-Za-z0-9_]
\d
\D
\s
?[\r\t\f\n\v]
\S
?[^\r\t\f\n\v]
/^/
?beggining
// /^Cal/
{min,max}
// /Oh{3,6} no/
{min,}
// /Haz{4,}ah/
{exact}
// /Tim{4}ber/
(?=...)
(?!...)
todo capture group ()
(|)
// /P(engu|umpk)in/g
()/1
?capture group
  // let testString = "test test test";
  // let reRegex = /(test)(\s)\1\2\1/;
  // let result = reRegex.test(testString); //true
¡/()X/¡ -> cuando queremos capturar el caracter que viene detrás de algo que se repeatStringNumTimes
// "hola como estas".match(/(^)\D/g) // ['h']
// los caracteres que no sean espacio que venga justo detrás de espacios
// "sHoRt AnD sToUt".match(/(\s)\S/g) //["A", "s"]

/^()()$/
//let repeatNum = "42 42 42";
//let reRegex = /^(\d+)(\s)\1\2(\d+)$/; // Change this line
//let result = reRegex.test(repeatNum);

String.prototype.replace() + capture groups
?const newStr = str.replace(regexp|substr, newSubstr|function)
// "The sky is silver.".replace(/silver/, "blue") // "The sky is blue"
String.prototype.replace() + capture groups + $x
"Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');

¡---04---debugging¡
console.log()
console.clear()
typeof()

todo --falsy values--
//evalúan a false
false
0
""
NaN
undefined
null

¡--05Data structure--¡

todo --arrays--
//array properties
length
//array methods
push()
unshift()
pop()
shift()
splice(arg1,arg2)
slice(arg1,arg2)
indexOf()
//spread operator
[...arr]
//array methods
every()

todo --object attribute adding
//1
object.property = 'value';
//2
object['property'] = 'value';
//3
let variable = 'property name';
object[variable] = 'value';

todo -- delete property
delete object.prperty;

todo- property checking
//method
hasOwnProperty(propertyName); //true/false
//keyword
in
? 'propertyName' in objectName //true/false

todo --iterate over an object keys
for (let variableName in objectName){}
//eg (borrar)
for (let user in users) {console.log(user);}

todo --methods
Object.keys()


*==fMAP========================================================-->
?==iSINTAXIS===================================================-->
*1. reduce()
//setup
const arr1 = [1,2,3,4];
const reducer = (acumulador, valorActual) => acumulador + valorActual;
//Si se invoca reduce pasándole como argumento sólamente la función el acumulador tomará el valor del elto 0 del array
const result = arr.reduce(reducer); //result = 1 + 2 + 3 + 4 = 10 
//2) Si se invoca reduce() pasándole un valor, éste es tomado por el acumulador y 
const result = arr.reduce(reducer,5); // result = 5 + 1 + 2 + 3 + 4 = 15

?==fSINTAXIS===================================================-->
todo==iTeoría==================================================-->
* 1. Se puede declarar más de una variable en la primera casilla de un for()
//en este caso habría que declararla con var, para que el ámbito salga del bucle y
//se pueda usar luego para devolver el string
function reverseString(str) {
  for (var reversedStr = "", i = str.length - 1; i >= 0; i--) {
    reversedStr += str[i];
  }
  return reversedStr;
}
*2. Análisis de una bonita función
  * 1. Se pueden separar en líneas distintas los métodos para darle más claridad
  * 2. Hay que ponerle las comillas a split("") y a join("") para que lo hagan caracter a caracter.
  * 3. El str pasa a ser array y de nuevo un string.
  * 4. Nunca se muta el string, va cambiando el objeto asociado.
function reverseString(str) {
  return str
    .split("")
    .reverse()
    .join("");
}

*3 tail recursion vs head recursion
todo Head recursión más simple
function recsum(x){
  if (x === 1){
    return 1;
  }else{
    return x + recsum(x - 1);
  }
}
¿Qué hace el intérprete?

recsum(3);
3 + recsum(2);
3 + 2 + recsum(1);
3 + 2 + 1 = 6;
Hasta que no se han ejecutado todas las veces la función no se suman los resultado

todo tail recursion
function tailrecsum(x, total = 0){
  if (x === 0){
    return total;
  }else{
    return tailrecsum(x-1, total + x);
  }
}
Interprete si tailrecsum(3) == tailrecsum(3,0)
tailrecsum(2, 3)
tailrecsum(1, 5)
tailrecsum(0, 5);-> 5
En este caso en cada paso se va calculando el resultado, de tal manera que en el último
ya sale. Implica menos operaciones y es más eficiente.

*4 new Array(x) se puede crear un array usando el constructor
new Array(x); siendo x el tamaño del array
* 5 reduce() ejecuta una función reductora que le pasamos como argumento sobre cada elto del array y devuelve un único valor
//setup
const arr1 = [1,2,3,4];
const reducer = (acumulador, valorActual) => acumulador + valorActual;
//Si se invoca reduce pasándole como argumento sólamente la función el acumulador tomará el valor del elto 0 del array
const result = arr.reduce(reducer); //result = 1 + 2 + 3 + 4 = 10 
//2) Si se invoca reduce() pasándole un valor, éste es tomado por el acumulador y 
const result = arr.reduce(reducer,5); // result = 5 + 1 + 2 + 3 + 4 = 15

*6 Prototypes
 * 1. Todos los objetos en JavaScript heredan propiedades y métodos de un prototype
 * 2. No se pueden añadir propiedades al constructor de un objeto con notación de punto
  Person.weight
* 3. Todos los objetos de JavaScript heredan de un prototipo:
  Objetos Date heradan de Date.prototype
  Objetos Array heredan de Array.prototype
* 4. Una vez creado un constructor de objeto se pueden añadir propiedaes usando la palabra clave prototype
Person.prototype.nacionalidad = "Español";
* 5. También se pueden añadir métodos

* 7. apply() 
//sin thisArg
const arr = [1,2,3];
Math.max.apply(null,arr) //3
//con thisArg
const arr1 = ['a','b'];
const arr2 = [1,2,3];
!queremos usar push pero si pasamos directamente un array a push mete un array dentro de un array
arr1.push.apply(arr1,arr2);
//para poder usar una función como push pero con un array usamos apply
//arr1 sería el contexto
//arr2 es el array que le pasamos a la función push
console.log(arr1); // ["a", "b", 0, 1, 2]


* 8: bind() 
  *1 Para entender qué hace bind primero tenemos que entender este snippet 
    const pepe = {
  edad: 36,
  getEdad: function(){
    return this.edad;
  }
  };
  //si no usamos bind
  const boundedGetAge = pepe.getEdad;
  console.log(boundedGetAge()); // undefined
  //si usamos bind
  const boundedGetAge = pepe.getEdad.bind(pepe);//36
  *2 Otro ejemplo
  this.x = 10; // este es el valor de x en el ámbito del this que es la ventana
  //el objeto edu tiene un método getX que devuelve this.x
  var edu = {
    x: 36;
    getX: function() {return this.x;}
  };
  //intentamos extraer el método del objeto edu por que es un método muy chulo
  var blas = edu.getX;
  blas();
  //cuando ejecutamos blas en lugar de devolver 34, que es el valor del this.x del ámbito del objeto
  //nos devuelve 10, que es el this.x del ámbito de la ventana. porque claro, estamos ejecutando la función
  function() {return this.x;} en el ámbito global
  //lo que hay que hacer es vincular (bind) la función, y especificar un ámbito desde el cual se ejecutará
  var epi = edu.getX.bind(edu);
  //o bien arreglar la función que está desvinculada
  var epi = blas.bind(edu);
  ahora sí al ejecutar blas(); dará 36

* 9 ámbito del this
si ponemos directamente:
this.x = 9; this se refiere a la ventana en al que hemos ejecutado el código.
Osea que x = 9 en la ventana. wow!
* 10 apply()-> viene de Function.prototype.apply()
?  func.apply(thisArg, [ argsArray])
  1. thisArg = El valor del this, es decir el contexto
* 11 Title case: la primera letra de cada palabra en mayúscula
* 12 JavaScript convierte directamente string primitivos en String objetos por lo que se 
  * pueden usar los métodos de String con los string primitivos.
* 13 No se puede usar la notación de arrow Function cuando estamos añadiendo un método 
  * al constructor de un objeto con prototype
* 14 Del repaso, el caracter punto no está includio en \w por supuesto. Si queremos incluir
  * cualquier caracter tenemos que poner .
* 15 Repaso, cuando ponemos /(\d)/1/ esto significa que puede ser cualquier número pero debe ser
  * el mismo
* 16 Boolean:
  * Las expresiones que se evalúan if(expresión) javascript las traduce forzadamente a boolean.
    * Eso se llama implicit type coercion
    if('hola'){console.log('coerced')} // "coerced"
    * Todos los valores coerce a "true", salvo:
    - NaN, null, undefined, 0, ''|"" y false que es un boolean-> se llaman falsy
    - false evalúa a false y no es falsy, es false
todo==fTeoría==================================================-->
!=iSNIPPETS===================================================-->
* 1. Un programa que recibe un string y devuelve el inverso
todo solución Edu 
function reverseString(str) {
  console.log(str);
  let long = str.length;
  console.log(long);
  let arr = [];
  let arrReversed = [];
  for (let i = 0; i < long; i++){
    arr.unshift(str[i]);
  }
  str = "";
  console.log(arr);
  for (let i = 0; i < long; i++){
    str += arr[i];
  }
  console.log(str);
  return str;
}

reverseString("hello");

todo solucion edu2
function reverseString(str) {
  let strCopy = str;
  str ="";
  for (let i = strCopy.length-1; i >=0; i--){
    str += strCopy[i];
    console.log(str);
  }
  return str;
}

reverseString("hello");

¡solución campera

function reverseString(str) {
  return str
    .split("")
    .reverse()
    .join("");
}

* 2. Una función que devuelve el factorial de un número que se le pasa por parámetro
todo solución edu
  function factorialize(num) {
  if(num <= 0){
    return 1;
  }else{
    return factorialize(num-1)*(num);
  }
}
todo camp 1
//1)inicializa y declara la variable  en el for
//2)Hace un for() invertido, empieza por num y llega hasta 1 con > 0
//3)Utiliza un *= para ir multiplicando sucesivamente
function factorialize(num) {
  for (var product = 1; num > 0; num--) {
    product *= num;
  }
  return product;
}

todo camp2
//1) Igual que mi solución pero el caso base es igual estricto a cero
function factorialize(num) {
  if (num === 0) {
    return 1;
  }
  return num * factorialize(num - 1);
}

todo camp3
//utiliza tail recursion en lugar de head recursion
function factorialize(num, factorial = 1) {
  if (num == 0) {
    return factorial;
  } else {
    return factorialize(num - 1, factorial * num);
  }
}

Paso de analizarlo por el momento

* 3 Una función que devuelva el tamaño del string más largo encontrado.
todo solución edu
function findLongestWordLength(str) {
  let word = "";
  let max = 0;
  let result = 0;
  for(let i = 0; i < str.length; i++){
    if(/\s/.test(str[i])){
      word = "";
      console.log('max ' + max);
    }else{
      word += str[i];
      max = word.length;
      if(max > result){
        result = max;
      }
    }
    

  }
  return result;
}
todo solución camp 
//uso de split con un espacio para separar cada palabra en un elto de un array
function findLongestWordLength(str) {
  var words = str.split(' ');
  var maxLength = 0;

  for (var i = 0; i < words.length; i++) {
    if (words[i].length > maxLength) {
      maxLength = words[i].length;
    }
  }

  return maxLength;
}

todo camp 2 usando reduce()
//pasa el string a un array que separa elementos cuando encuentra espacios
//usa reduce sobre el array para quedarse con el máximo las dos palabras que va comparando
//x es el acumulador que pone a cero antes de que comience la fiesta
// después va comparando dicho número con la longitud del elemento siguiente
// usando la función Math.max se queda con el máximo de entre esos dos: el acumulador o el elto siguiente del array.
let reducer = function (x,y){
  return Math.max(x, y.length);
}
return s.split(' ').reduce(reducer,0);

function findLongestWordLength(s) {
  return s.split(' ')
    .reduce(function(x, y) {
      return Math.max(x, y.length)
    }, 0);
}

todo camp 2 modificada con arrow function (Qué bonita!)
function findLongestWordLength(str) {
  return str
    .split(' ')
    .reduce((x,y) => Math.max(x,y.length),0);
}

todo camp 3 usando map()
//de derecha a izquierda
//a map() le llega un array en el que están todas las palabras del array una por elemento
// esto se lo ha proporcionado el método split(" ") con una separación
// map() lo que hace es aplicar una función a cada elto de un array y devolver otro array
// en este caso lo que hace es simplemente medir la longitud de cada palabra y devolver su número
// dicho array le llega al spread operator, que lo que hace es básicamente quitar los corchetes del array
//por último Math.max elige, de entre todos los eltos el mayor y lo devuelve.
function findLongestWordLength(str) {
  return Math.max(...
                   str
                  .split(" ")
                  .map(word => word.length));
}

* 4 Una función que devuelva un array con el mayor de los elementos del sub-array
todo solución edu
//setup éste es el tipo de array
largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);
//función
function largestOfFour(arr) {
  return arr.map(x => Math.max(...x));
}
todo solucion camp (declarative approach)
//usa map() sobre el array
//le pasa una función que lo que hace es devolver un reduce()
//el reduce usa una función con un condicional ternario que funciona:
// si el actual es mayor al acumulador devuelve el actual, si no devuelve el acumulador
// Por lo tanto lo que está ocurriendo es que se hace un map del array completo y cada
// subarray 
function largestOfFour(arr) {
  return arr.map(function(group) {
    return group.reduce(function(prev, current) {
      return current > prev ? current : prev;
    });
  });
}
¡análisis
todo anterior refactorizado con mis variables y arrow function
function largestOfFour(arr) {
  return arr.map( 
    subArray => subArray.reduce(
      (cur,prev) => cur > prev ? cur: prev 
    )
  )
}
todo solución camp 2 (apply & bind) un poquillo rebuscado y al final no lo he entendido muy bien
//pero me ha servido para entender mejor como funciona apply y bind de Function así como prototype
function largestOfFour(arr) {
  return arr.map(Function.apply.bind(Math.max, null));
}
¡análisis!
    *1. Si el array que le pasamos fuese un array simple tipo [1,2,3,4] ; con este snippet habríamos termiando
    *2. Lo que estamos haciendo es usar apply-> que viene de Function.prototype.apply()
    *3. El primer argumento thisArg es null porque Math.max no necesita contesto para el this
    function largestOfFour(arr) {
      return Math.max.apply(null,arr);
    }
    *4 Ahora bien, lo que queremos meter en la función es un array anidado [[1,2],[3,4]] por lo que tenemos primero que mapear
      * antes de nada para quedarnos con los sub-arrays
    function largestOfFour(arr) {
      return 
        arr
        .map(Math.max.apply(null,arr)); // no vale
    }  
    *5 map() necesita que le pasemos una funcion no una expresión, así pues usamos Function.prototype.bind()
    function largestOfFour(arr) {
      return 
        arr
        .map(Function.apply.bind())
    }
    *6 como tanto apply() como bind() son métodos estáticos del mismo objeto Function los podemos encadenar
    *7 ahora, el método bind, que se ejecuta primero necesita un ámbito o contexto, que se provee en el primer argumento (thisArg)
    ? function.bind(thisArg[, arg1[, arg2[, ...]]])
      * le pasamos como ámbito Math.max() para poder ganar su funcionalidad (ni idea) y como argumento 
      * como segundo argumento no hace falta poner nada (no sé no entiendo realmente porqué)
      * así que queda 
    function largestOfFour(arr) {
      return 
        arr
        .map(Function.apply.bind(Math.max,null));
    }
* 5 Declara una clase y usa el getter para mostrar un valor además de un método de dicho objeto
class Personita{
  constructor(age){
    this._age = age;
  }
  get age(){
    return this._age;
  }
  present (){
    return 'My name is: ' + this._age;
  }
}
console.log(new Personita(35).age) //35
console.log(new Personita(35).present()) // "My name is: 35"

*6 Una función que comprueba que un string termina en otro string o no
todo solución edu
//explicación
* 1. utilizo el constructor de expresiones regulares para poder usar un patrón dinámico (para usar el valor que se le pasa
  * como argumento "target") porque no me debaja usar el literal -> //
* 2. utilizo la notación de template literal para generar un string
* 3. uso ${} para poner la variable y le coloco detras $ que marca en regex si algo termina con una expresión
* 4. uso el método test de RegExp() para comprobar si el patrón se da en el string que estamos recibiendo como argumento.
function confirmEnding(str, target) {
  let myRegex = new RegExp(`${target}$`);
  return myRegex.test(str);
}

confirmEnding("Bastian", "n");

todo solución camp 1
//slice() extrae una sección del string y lo devuelve sin modificar el string original
// Resta la longitud total de la longitud del string final
// con lo que queda usa slice(x)
// al tener un solo argumento lo que hace slice es cortar a partir del índice que le damos
// después compara eso que ha cortado con el target
? str.slice(beginIndex[, endIndex])
function confirmEnding(str, target) {
  return str.slice(str.length - target.length) === target;
}

todo solución camp2 usando constructor
function confirmEnding(str, target) {
  const myRegex = new RegExp(target + "$");
  return myRegex.test(str);
}

todo solución camp 3 usa argumento negativo con slice
function confirmEnding(str, target) {
  return str.slice(-target.length) === target;
}

* 5 Una función que devuelve un str concatenado un número de veces
todo solución edu
function repeatStringNumTimes(str, num) {
  const result = [];
  if( num > 0){
    for(let i = 0 ; i < num; i++){
      result.push(str);
    }
    return result.join('');
  }else{
    return "";
  }
}
todo solucion camp 1
//accumulatedStr no puede ser const porque vamos a ir generando y asignando diferentes objetos string a la misma variable
//recuerda que los string son inmutables
function repeatStringNumTimes(str, num) {
  var accumulatedStr = "";

  while (num > 0) {
    accumulatedStr += str;
    num--;
  }

  return accumulatedStr;
}

todo solucion camp 2 recursiva
function repeatStringNumTimes(str, num) {
  if (num < 1) {
    return "";
  } else if (num === 1) {
    return str;
  } else {
    return str + repeatStringNumTimes(str, num - 1);
  }
}
todo solución camp 3 recursiva con ternario
function repeatStringNumTimes(str, num) {
  return num > 0 ? str + repeatStringNumTimes(str, num - 1) : '';
}

* 6 Una función que corta el sobrante de un string y le añade tres puntos. 
todo version edu
//paso el string a array para poder usar slice y luego lo uno con join
function truncateString(str, num) {
  return(str.length > num) ? str
                            .split('')
                            .slice(0,num)
                            .join('') 
                            + '...'
    : str;
}

todo version camp
//resulta que no es necesario pasar a array porque el String.prototype tb tiene el método slice()
function truncateString(str, num) {
  return str.length > num ? str.slice(0, num) + "..." : str;
}

todo version camp refactorizada edu
function truncateString(str, num) {
  return (str.length > num)
    ? str.slice(0,num) + "..." 
    : str;
}

* 7 Una función que al pasarle un array y una función nos devuelve el primer elemento del array que satisface
  * test, si no, devuelve undefined  
  todo solucion edu
  //filter() devuelve un array vacío si ningún elto pasa el test, si intentamos acceder al primer elemento del 
  // array vacío este devuelve undefined
function findElement(arr, func) {
  let num = arr.filter(func)[0];
  return num;
}
todo solucion camp 1
//usa un bucle for para iterar sobre el array, le pasa el valor del elto a la función 
//y si devuelve true, devuelve el nº, si no devuelve undefined
function findElement(arr, func) {
  let num = 0;

  for (var i = 0; i < arr.length; i++) {
    num = arr[i];
    if (func(num)) {
      return num;
    }
  }

  return undefined;
}

todo solucion camp 1 refactorizado edu
function findElement(arr, func) {
  let num = 0;
  for(let i = 0; i <arr.length; i++){
    if (func(arr[i])){
      return arr[i];
    }
  }
  return undefined;
}

todo solucion camp 2 usando find()
function findElement(arr, func) {
  return arr.find(func);
}

todo solucion camp 3 
// De dentro a afuera mapeamos todos los eltos usando la funcion "func"
// al usar indexOf(true) devuelve el índice del primer elemento cuyo
// arr.map(func) devuelve un array tal que así ['false', 'true', 'false']
// xq las funciones que le pasamos devuelven true/false como esta
// findElement([1, 2, 3, 4], num => num % 2 === 0);
// arr[1]-> por ejemplo dará el valor de ése indice
function findElement(arr, func) {
  return arr[arr.map(func).indexOf(true)];
}

* 8 Una función que devuelve true/false si lo que se le pasa por argumento es o no un boolean
todo edu
function booWho(bool) {
  return typeof(bool) === 'boolean';
}
todo camp1function booWho(bool) {
//al ser typeof un operador no hace falta poner paréntesis como en los métodos/funciones
  return typeof bool === 'boolean';
}

* 9 Una función que reciba un string y devuelva un string en el que todas las palabras empiezen por
  * mayúscula y el resto en minúscula
  todo edu solución
  function titleCase(str) {
  
  return str.split(' ').concat()
                          .map(word => word.split(''))
                          .map(subArray => { var result = "";
                                             for(let i = 0; i < subArray.length; i++){
                                               if(i === 0){
                                                 result += subArray[i].toUpperCase();
                                               }else{
                                                 result += subArray[i].toLowerCase();
                                               }
                                             }
                                            return result;
                                           }).join(' ')
                          
           ;
}

titleCase("I'm a little tea pot");

todo solucion camp1
¡análisis¡
* 1. Añade una función al objeto String (cosa que no  está recomendada)
* 2. La función recibe como parámetro un índice y un caracter que puede ser más de uno
* 3. Devuelve un nuevo string que reemplaza que cambia el caracter del string por el/los
  * caracter/es que le pasamos
* 4. El truco es que al añadir este método al objeto String, todos los strings que creamos
  * van a tener este método replaceAt(), que además podremos invocar desde el propio objeto
* 5. Esto es posible porque JavaScript convierte los string primitivos en objetos String
* 6. Tambien es posible gracias a que prototype permite añadir métodos a un constructor tal
  * como se muestra en el código.
* 7 se utiliza un bucle for...in para iterar sobre el array
* 8 Guarda en newTitle el array de hacer split con el string, de manera que cada elto del string
  * es una palabra
* 9 Crear otra variable donde almacena un array nuevo
* 10 usa un for...in para recorrer todos los eltos del array spliteado
* 11 Ahora por cada palabra del array hace lo siguiente:
  * 1. copia la palabra completa
  * 2. la pasa toda a minúsculas
  * 3. reemplaza la primera letra de cada palabra con la función antes creada
  * 4. Para acceder a la letra que quiere usa el método charAt the String
* 12 Una vez tiene el nuevo string con todas la palabras cambiadas las pasa a 
  * un string con join(" ") con espacio. y lo devuelve.
String.prototype.replaceAt = function(index, character) {
  return (
    this.substr(0, index) + character + this.substr(index + character.length)
  );
};

function titleCase(str) {
  var newTitle = str.split(" ");
  var updatedTitle = [];
  for (var st in newTitle) {
    updatedTitle[st] = newTitle[st]
      .toLowerCase()
      .replaceAt(0, newTitle[st].charAt(0).toUpperCase());
  }
  return updatedTitle.join(" ");
}
todo solucion anterior refactorizada edu
String.prototype.reemplazaEn = function(indice,letra) {
  return this.substr(0,indice) + letra + this.substr(indice + letra.length);
}

function titleCase(str) {
  const nuevoTitulo = str.split(" ");
  const actualizado = [];
  

  for (let palabra in nuevoTitulo){
    actualizado[palabra] = nuevoTitulo[palabra]
                          .toLowerCase()
                          .reemplazaEn(0,nuevoTitulo[palabra].charAt(0).toUpperCase())
                          ;              
  }
  
  return actualizado.join(" ");
}

titleCase("I'm a little tea pot");

todo solucion camp 2
¡análisis¡
* 1. crea una función que en un paso convierte el string en minúsculas y luego 
  * lo pasa a un array separado por espacios
* 2. en otra variable almacena un array resultado de mapear el array anterior.
* 3. Qué función se está mapeando
  * 1. coge una palabra
  * 2. usa replace() para cambiar la primera letra del String por la misma pero en mayúsculas
* 4 Devuelve el join de dicho array
// me gusta mucho esta solución porque es muy legible, ¿Por qué es tán legible?
// 1 primero hace un par de pasos y los guarda poniendo un buen nombre de variable
// 2 después usa ese resultado par hacer un mapeado
// 3 es fácil de seguir es limpio sencillo hermoso, bello en sí mismo.
function titleCase(str) {
  var convertToArray = str.toLowerCase().split(" ");
  var result = convertToArray.map(function(val) {
    return val.replace(val.charAt(0), val.charAt(0).toUpperCase());
  });
  return result.join(" ");
}

titleCase("I'm a little tea pot");

todo version anterior refactorizada edu
function titleCase(str) {
  const lowerCaseArray = str.toLowerCase().split(" ");
  const result = lowerCaseArray.map(
    function(valor){
      return valor.replace(valor.charAt(0),valor.charAt(0).toUpperCase())
    }
  )
  return result.join(" ");
}

todo camp 3 regex solution
function titleCase(str) {
  return str.toLowerCase().replace(/(^|\s)\S/g, L => L.toUpperCase());
}
* 10 [repaso] 
1) Usernames can only use alpha-numeric characters.
2) The only numbers in the username have to be at the end.
 There can be zero or more of them at the end. Username cannot start with the number.
3) Username letters can be lowercase and uppercase.
4) Usernames have to be at least two characters long.
 A two-character username can only use alphabet letters as characters.
todo edu
let pass = ""
let regex = /^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i
regex.test(pass)

* 11 [repaso]
Use lookaheads in the pwRegex to match passwords that are greater than 
5 characters long, do not begin with numbers, and have two consecutive digits.
/(?=^\D)(?=\w{5,})(?=\w*\d{2})/

* 12 [repaso]
let testString = "test test test";
let reRegex = /(test)(\s)\1\2\1/;
let result = reRegex.test(testString);
¡analisis¡
la traducción de del regex
(test) = 1º
(\s)   = 2º
/(test)(\s)\1\2\1/ = test\s + (1º)(2º)(1) = test\s + test\s\test = test\stest\stest\ = test test test

* 13 [repaso]
let repeatNum = "42 42 42";
let reRegex = /^(\d+)(\s)\1\2(\d+)$/;
let result = reRegex.test(repeatNum);
¡análisis¡
* ¿Por qué éste regex /(\d+)(\s)\1\2\1/ deja pasar 42 42 42 42?

Requerimiento 42\s42\s42
Actual        42\s42\s42\s42
¿Cumple Actual el requerimiento?
Si lo cumple,  luego pasará el test
Actual        42\s42\s42\s42\s42 también cumpliría y así
¿Cómo nos aseguramos que sólo se repita tres veces?
- Hacemos que:
^(\d+) empiece por un número de 1 o más cifras
(\s) tenga un espacio
\1 se repita el mismo número
\2 se repita el espacio
(\d+)$ se vuelva a repetir el número pero que éste sea el último!!!  :D

*Un regex que elimina espacios al comienzo y al final (similar a Stryng.prototype.trim())
let hello = "   Hello, World!  ";
let wsRegex = /^\s+|\s+$/g;
let result = hello.replace(wsRegex,""); 

* 14. Una función que cambia un String a Title String (comienzo de palabras en mayúscula)
todo solucion camp refactorizada edu
¡analisis¡
* 1 Explicación del regex
  * 1. Cuando ponemos con capture group (//) seguido de cualquier expresion lo que hacemos es
    * primero se filtran los caracteres del capture group y luego se eligen los caracteres que van detrás
  * 2. Así al poner /(^)\w/ -> estamos diciendo coge todos los caracteres alfanuméricos que vayan detras de un espacio.
  * 3. por eso /(^\s)\w/ -> significa
    * a: primero filtra por caracteres que van detrás del comienzo del string o caracteres que vayan detras de un espacio
    * b: quédate con cualquiera de los caracteres alfanuméricos que vayan detras de uno de los dos anteriores
  * 4. Ahora pasa todos los caracteres a minúscula del string, todos.
  * 5. de ellos usa replace con el regex y una función
  * 6. esto hace como un map() de los regex y aplica la función a todos los caracteres que encuentra que hacen match con el regex
  * 7 así lo que cambia son todos los caracteres por mayúscula. 
function titleCase(str) {
  const myRex = /(^|\s)\w/g
  const myFunc = letter => letter.toUpperCase();
  return(str
        .toLowerCase()
        .replace(myRex, myFunc));
}

titleCase("I'm a little tea pot");

* 15. Inserta los eltos de un array en otro array en un lugar concreto

You are given two arrays and an index.
Copy each element of the first array into the second array, in order.
Begin inserting elements at index n of the second array.
Return the resulting array. The input arrays should remain the same after the function runs.
todo solución edu
function frankenSplice(arr1, arr2, n) {
  const result = [...arr2];
  result.splice(n,0,...arr1);
  return result;
}

frankenSplice([1, 2, 3], [4, 5, 6], 1);

todo solucion camp 1
//hace una copia del array con slice()
// con un for copia elto a elto el otro array dentro
// lo que va cambiando es el índice 
function frankenSplice(arr1, arr2, n) {
  // It's alive. It's alive!
  let localArray = arr2.slice();
  for (let i = 0; i < arr1.length; i++) {
    localArray.splice(n, 0, arr1[i]);
    n++;
  }
  return localArray;
}
todo solución camp2
//primero hace una copia con slice
// luego inserta con spread operator 
function frankenSplice(arr1, arr2, n) {
  // It's alive. It's alive!
  let localArr = arr2.slice();
  localArr.splice(n, 0, ...arr1);
  return localArr;
}

* 16 Una función que elimina de un array todos los eltos que valgan "falsy"
todo edu filter() 
function bouncer(arr) {
  return arr.filter( element =>{
    if(element){return element;}
  });
}

bouncer([7, "ate", "", false, 9]);
todo camp1
//simplemente recorre el array y guarda en otro los elementos truthy
function bouncer(arr) {
  let newArray = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) newArray.push(arr[i]);
  }
  return newArray;
}

todo camp2
//filter está usando un objeto Boolean como si fuera una función para evaluar el valor de cada
//uno de los elementos del array que se le están pasando
function bouncer(arr) {
  return arr.filter(Boolean);
}

* 17 Una función que recibe un array de números y devuelve el índice en el que habría
  * que insertar un número en caso de que el array estuviese ordenado para que siguiese
    * estándolo tras insertar el número

todo solucion edu ( sort() + findIndex)
function getIndexToIns(arr, num) {
  let sorted = arr.sort((a,b) => a-b);
  let result = sorted.findIndex( element => element >= num )
  
  return result < 0 ? sorted.length : result
}
todo solucion camp1
//ordena con sort
// recorre todo el array, devuelve el índice del elto que es o igual o mayor 
// si no es igual o mayor devuelve la longitud del array
// es igual que mi solución pero sin usar findIndex
function getIndexToIns(arr, num) {
  arr.sort(function(a, b) {
    return a - b;
  });

  for (var a = 0; a < arr.length; a++) {
    if (arr[a] >= num) return a;
  }

  return arr.length;
}

todo camp2
//va contando el número de eltos que son mayores que el número en cuestion
//ése sería su índice
function getIndexToIns(arr, num) {
  var times = arr.length; // runs the for loop once for each thing in the array
  var count = 0;
  for (var i = 0; i < times; i++) {
    if (num > arr[i]) {
      count++;
    }
  } // counts how many array numbers are smaller than num
  return count; // the above equals num's position in a sorted array
}
todo refactor of camp2
function getIndexToIns(arr, num) {
  for(var i = 0, a = 0; i < arr.length; i++){
    if(num > arr[i]) a++;
  }
  return a;
}

todo camp3
//ordena
//hasta que el número no sea mayor que el elto, sigue aumentando el índice
//en otras palabras: se queda con el índice del primer elemento en el que 
// el número es mayor al array
function getIndexToIns(arr, num) {
  arr.sort(function(a, b) {
    return a - b;
  });

  var i = 0;
  while (num > arr[i]) {
    i++;
  }

  return i;
}

todo camp 4
//dios mio cómo no he caído en esto
//primero mete el número con push
//luego ordena el array
//después devuelve el índice del número
function getIndexToIns(arr, num) {
  arr.push(num);
  arr.sort(function(a, b) {
    return a - b;
  });
  return arr.indexOf(num);
}

todo camp5
//esta solución es como la mía
//la única diferencia es que usa -1 como especificación en lugar 
//de < 0. es un poco mejor porque es más específico
function getIndexToIns(arr, num) {
  // sort and find right index
  var index = arr
    .sort((curr, next) => curr - next)
    .findIndex(currNum => num <= currNum);
  // Returns proper answer
  return index === -1 ? arr.length : index;
}

todo camp6
//qué elegante coño
//CREA un nuevo array (vamos que ni modifica el original qué maravilla) añadiéndole el elto
// lo ordena con un sort con su array function (si es que, que bonito)
// devuelve el índice del elto con indexOf
function getIndexToIns(arr, num) {
  return arr
    .concat(num)
    .sort((a, b) => a - b)
    .indexOf(num);
}

todo camp7
// es igual que el método 2 pero con métodos
function getIndexToIns(arr, num) {
  return arr.filter(val => num > val).length;
}

* 18 Una función que, dado un array de dos elementos devuelva true si todas la letras del segundo existen en el primero
  * de lo contrario devuelve false
todo  edu
function mutation(arr) {
  console.log(`/[${arr[0]}]/`)
  const myRegex = new RegExp(`[${arr[0]}]`,'i') ;
  console.log(myRegex)
  
  const arr2 = arr[1]
              .split("")              
              .filter( element => myRegex.test(element))
              .join("");

  return arr2.length == arr[1].length; 
  
  
}

mutation(["hello", "hey"]);

todo camp 1 procedural
//cambia ambos array a minúsculas y los almacena en otras variables
// indexOf de cada una de los eltos del segundo elto del array contra el primero.
// usa indexOf() de manera que cuando no encuentra nada, devuelve -1 -> false
// si indexOf siempre encuentra un número positivo, no dará negativo, así que da uno
//positivo
function mutation(arr) {
  var test = arr[1].toLowerCase();
  var target = arr[0].toLowerCase();
  for (var i = 0; i < test.length; i++) {
    if (target.indexOf(test[i]) < 0) return false;
  }
  return true;
}
todo camp1 refactor ed
function mutation(arr) {
  const target   = arr[0].toLowerCase();
  const test = arr[1].toLowerCase();

  for(let i = 0; i < test.length; i++){
    if (target.indexOf(test[i]) === -1) return false
  }

  return true;
}

todo camp2
// le pasa arr1 (test) en minúsculas y lo splitea letra a letra en un array.
// ese array que tiene letra a letra la segunda palabra le hace pasar un every()
// la función de every es una condición:
// existe dicha letra en el otro array? target
// cómo le pregunto eso al otro array?
// devuelve el otro String, en minúsuclas, indexOf ( en qué índice está esta letra)
// si no encuentra alguna, dará negativo, y como every sólo da true si todos los elementos
// pasan la prueba, pues ya estaría.
function mutation(arr) {
  return arr[1]
    .toLowerCase()
    .split("")
    .every(function(letter) {
      return arr[0].toLowerCase().indexOf(letter) != -1;
    });
}
todo refactor edu
function mutation(arr) {
  return arr[1]
         .toLowerCase()
         .split("")
         .every(element =>
            arr[0].toLowerCase().indexOf(element) != -1
         )
  ;
}

mutation(["hello", "hey"]);

todo camp 3 recursive
¡analisis¡
* 1. Define la función con dos argumentos: un array y un índice
    * 1. El índice comienza valiendo cero, cosa que hace pasándole un valor en la definición de la función
    * 2. El array tiene dos valores: target y test
    * Me parece muy pero que muy guapo definir una función así para poder ir reutilizándola joder.
* 2. Al estar usándolas como parámetros de la función las variables target y test no hace falta almacenarlas en variables
  * dentro de la función. Esto también me encanta.
  * Es gracioso que en cada recursión se intentará poner los strings en minúsculas pero sólamente en la capa más alta se hará algo
  * esto es un poco ineficiente pero weno da igual.
* 3. controla la recursión con el índice i ,como si fuera un while. En el momento que i alcanza a tener el mismo tamaño
    * que la cadena test, que es la que estamos probando, se cierra la recursión.
    * a-> true -> la función devuelve true
    * b-> false Vuelve a hacer otra pregunta:
* 4. ¿El molde (target) NO contiene la letra que corresponde a aquella que se encuentra en el lugar correspondiente por el que vamos?
  * a-> true-> osea que no la tiene-> pues ya sabemos que el model no contiene todas las letras. La función devuelve false
  * b-> false-> es decir, que sí que la tiene, por lo que se vuelve a iterar en la recursión
    * -> se invoca a la función, a la que se le pasa el array con target y test, que vienen definidas de la primera capa
      * y se pasan a la segunda
    * -> el segundo parámetro es la i + 1 unidad
  * Está muy bonito este problema

function mutation([ target, test ], i = 0) {
  target = target.toLowerCase();
  test = test.toLowerCase();
  return i >= test.length
    ? true
    : !target.includes(test[i])
      ? false
      : mutation([ target, test ], i + 1);
}

todo camp 3 recursive refactorizado edu
//sin darme cuenta he implementado indexOf en lugar de includes y ha funcionado sin pensar
//esto me llena de felicidad porque al haber entendido el algoritmo he podido adaptarlo 
//"on the fly" con mis propias herramientas
function mutation([target,test] ,  i = 0) {
  target = target.toLowerCase();
  test = test.toLowerCase();
  return i >= test.length
    ? true
    : target.indexOf(test[i]) === -1
      ? false
      : mutation([target,test] , i + 1)  
}

mutation(["hello", "hey"]);

* 19. Una función que recibe un array y un número devuelve un array de arrays cuyo tamaño es el número.
  * resultado de cortar el array

todo solución edu 1
  function chunkArrayInGroups(arr, size, result = []) {

  while(arr.length > 0){
    result.push(arr.slice(0,size));
     arr.splice(0,size);
  }
  return result;
}

chunkArrayInGroups(["a", "b", "c", "d"], 2);

todo sol camp 1
// El módulo de dividir cualquier número entre otro que sea mayor que él es siempre el mismo número
// 2 % 4 = 2; 2 % 5 = 2 etc.
// Así cuando hacemos a % size !== -1 estamos diciendo
// siempre que el índice sea distinto de del tamaño que queremos cortar menos 1
// se copia el elemnto al array temporal
// cuando el índice sea menor en una unidad al tamañao que queremos cortar, lo que hacemos es
// se pasa el elto al aray temporal, dicho array temporal se mete en el array final
// se vacía el array temporal 
// Por qué tiene que ser size -1? porque el primer elemtno de un array es 0 y tenemos que
// empezar por ahí. así que el elto final de cadad corte está marcado por size -1
// al final se comprueba si ha sobrado algo, en temp, es decir si no se llega a 
// abarcar el tamaño de corte pues va a sobrar un trozo, pues se pone el en array final y
// luego se devuelve
! if()code;else{} se puede poner un else despues de un if de una sola línea
! if()code;else code;
! () ? code : code;

function chunkArrayInGroups(arr, size) {
  var temp = [];
  var result = [];

  for (var a = 0; a < arr.length; a++) {
    if (a % size !== size - 1) temp.push(arr[a]);
    else {
      temp.push(arr[a]);
      result.push(temp);
      temp = [];
    }
  }

  if (temp.length !== 0) result.push(temp);
  return result;
}
todo camp 1 refactor
function chunkArrayInGroups(arr, size) {
  let temp = [];
  let result = [];

  for ( let i = 0; i < arr.length; i++){
    if(i % size !== size -1) temp.push(arr[i]);
    else{
        temp.push(arr[i]);
        result.push(temp);
        temp = [];
    }
  }

  if(temp.length !==0) result.push(temp);
  return result;
}

todo camp2
//Esto es lo que yo intenté hacer la primera vez pero me salió un loop infinito
// el índice va aumentando con el tamaño del trozo, eso sí lo pensé
// joder era tan fácil como slice(i, i + size) cada vez.
// el índice se va a mover
// se hace un corte desde i hasta el size. es muy sencillo.
function chunkArrayInGroups(arr, size) {
  // Break it up.
  var arr2 = [];
  for (var i = 0; i < arr.length; i += size) {
    arr2.push(arr.slice(i, i + size));
  }
  return arr2;
}
todo camp 2 refactor
!fallo conceptual: en la tercera expresión del for hay que escribir un acumulador
! recuerda que i++ es i+= 1 o i = i + 1
! en este caso tendría que ser i += size o i = i + size
! se tiene que referenciar la i a sí misma en una pequeña recursión
! no valdría i + size como puse yo porque entonces siempre sería el mismo valor cte
! por eso el bucle era infinito.
function chunkArrayInGroups(arr, size) {
  "use strict"
  const arr2 = [];
  for(let i = 0; i < arr.length; i += size){
    console.log('i:'+ i)
    arr2.push(arr.slice(i, i+size));
  }

  return arr2;
}

todo camp 3
// crea un array vacío y un contador
// en un bucle while, condicion: hasta que i llegue al tamaño del array
// se pasa el trozo
// se aumenta el contador en size
function chunkArrayInGroups(arr, size) {
  // Break it up.
  var newArr = [];
  var i = 0;

  while (i < arr.length) {
    newArr.push(arr.slice(i, i + size));
    i += size;
  }
  return newArr;
}

todo camp4 refactor
function chunkArrayInGroups(arr, size) {
  "use strict"
  let arr2 = [], i = 0;

  while( i < arr.length){
    arr2.push(arr.slice(i,i + size));
    i += size;
  }

  return arr2;
  
}
todo camp 5 recursiva
//primero recordemos que slice(x) cuando se invoca así, devuelve un nuevo array
// que abarca desde el número que le pasamos como argumento hasta el final.
// El core de esta recursión es: 
  * f(arr,size) función básica toma un array y un tamaño como parámetro
  * Introducimos la recursión en el parámetro del array
    * [arr.slice(0,size)] -> este trozo equivale al trozo del array que debemos cortar
      * desde la izquierda
    * [arr.slice(0,size)].concat() -> al ponerle seguido un concat lo que hacemos es que 
      * así en cada recursión se irán concatenando dichos trozos de la izquierda. Pero con qué?
        * arr.slice(size) con el trozo de la derecha
      * Si lo pensamos bien:
       !Trozo izquierdo: arr.slice(0,size)
       !Trozo derecho arr.slice(size)
      * El trozo izquierdo se va a procesar en esta iteración
        return arr.slice(0,size)
      * pero necesitamos que vaya dentro de un array
      return [arr.slice(0,size)]
      * el trozo derecho lo procesará la siguiente iteración, pero tiene que ir unido a este
        * para cuando el stack se impiece a resolver desde el caso base
      return [arr.slice(0,size)].concat()
      * Piensa, Cómo le pasamos a la función "el trozo de la derecha que va quedando"?
      f(arr.slice(size),size)
      * la función se llama a sí misma
      return [arr.slice(0,slice)].concat(f(arr.slice(size),size));
      * Ahora, cuando se termina le recursión, cuando se cumple las condiciones para llegar al caso base?
      [arr] 
      * Este sería el caso base, que en nuestro caso es el trozo que queda porque la condición que cierra el loop es:
      (arr.length <= size)
      * Exacto, que el trozo que quede sea igual o menor que size
      * Recordemos que cada vez que hacemos una recursión, le vamos pasando una copia del array original
        * al que le faltan size elementos, por lo que cada vez es más pequeño
        * Ahí está el punto que no era capaz de sacar, cómo hago que la función sea cada vez más pequeña, cómo iterar eso.
        * pensé en hacer un splice pero no tenía sentido porque eso modifica el array original. 

function chunkArrayInGroups(arr, size) {
  if (arr.length <= size) {
    return [arr];
  } else {
    return [arr.slice(0, size)].concat(
      chunkArrayInGroups(arr.slice(size), size)
    );
  }
}
todo camp 4 refactor (igual pero usor Array.of() en lugar del literal [])
function chunkArrayInGroups(arr, size) {
  if (arr.length <= size) return Array.of(arr);
  else return Array.of(arr.slice(0,size)).concat(chunkArrayInGroups(arr.slice(size),size));
}
console.log(chunkArrayInGroups(["a", "b", "c", "d"], 2))
chunkArrayInGroups(["a", "b", "c", "d"], 2);

!=fSNIPPETS===================================================-->