# javaScriptAlgorithmsDataStructuresFreecodecamp
## Basic Algorithm Scripting
Start:  23/08/2020
Pomodoros:  
Notas: 
    - "Better Comments" ; Visual Studio Code
    - Uso comentarios con colores 
    
¡---------------------------------------------------------------->  
//--------------------------------------------------------------->
*==iMAP========================================================-->

todo --class, getters & setters--
class
get
set
constructor
//class
class ObjectName{
  constructor(x){
    this._attribute = x;
  }
  get attribute(){
    return  this._attribute;
  }
  set temperature(y){
    this._temperature = y;
  }
}
//use
const ObjectName = new ObjectName(z); //constructor use
let temp = ObjectName.attribute; //getter use
ObjectName.attribute = value; //setter use

todo --promise--
¡---
Promise
resolve
reject
then
catch
¡---
?syntax
const makeServerRequest = new Promise((resolve,reject) =>{
    if(condition){
        resolve("Promise fulfilled");
    }else{
        reject("Promise rejected");
    }
});

makeServerRequest.then(result => {
  console.log(result);
});

ServerRequest.catch(error =>{
  console.log(error);
})
?syntax

//estados de una promesa
pending
fulfilled()
rejected()

todo --import/export--
¡---
import
export
as
from
./
¡---
//file.js both in the same directory "./"
export {function1,function2};
import {function1,function2} from './index.js';
import * as myObject from './index.js';
//default fallback
export default function(){}
import variableName from "./index.js";

todo --built in Objects--
Date()
String()
Number()
Boolean()
Array()
RegExp()
Function()


todo --variables--
const
var
let


todo --ternary conditional--
(condition) ? code-true : code-false;

todo --shorthanded ternary?
// devuelve true si se cumple la condición y devuelve false si no se cumple la condición
return (condition); 
//ejemplo borrar pronto
return arr.indexOf(elem) != -1;


todo --loops--
while(cond){}
for ([initialization]; [condition]; [final-expression]){}
do{}while(condition);
if(){}else{}else return;


todo --object
var object = {att=value};
{} -> object literal
.
["']
delete -> para borrar un atributo de un objeto



todo --flux--
if
else if
else
switch
case
break
default

todo --definición de funciones--  
function myFunction(){}
let/var/const = function(a,b){};
x = Function()
//arrow functions
const x = () => {}
const x = () => "value"
const x = item => item * 2;
const x = (item1, item2) => item1 * item2;
//arrow function + object property shorthand
const x = (item1, item2) => ({item1 , item2}); 

todo --spread operator--
...

todo --rest parameter--
...

todo --memory structures--
[[{}],[{}]]

todo --methods of Global? Object--
Math.min()
Math.max()
Math.floor()
Math.random()
Math.round()
console.log()
parseInt()
  :* parseInt("")
  :* parseInt ("", radix)
Object.freeze()


todo --methods of objects--

//--string methods
repeat()
//--string + array methods
hasOwnProperty(propname) 
push()
pop()
shift()
unshift()
match()
splice()
concat()
tuUpperCase()
//other string methods
?produce un array con el string cortado letra a letra
split('')
?produce un array cuyos elementos son palabras separadas, el espacio separa una palabra de otra
split(' ')
join('')
?une todos los caracteres de un array y forma un string
//no se usaron
split()
join()

//--array methods
map()
filter()
reduce()
slice()
//--other array methods
reverse()
fill()
 
//especiales
call()
apply()




todo --properties--
'vale para strings y para arrays (borrame cuando me entiendas bien)
.length 

todo --tipos--
undefined 
null
boolean
string
symbol
bigint
number
object 

todo --operators--
: ! -> not
= -> asignación
+ -> adición/concatenation : number/string
- -> substraction
:* -> multiplication
/ -> division
++ -> increment
-- -> decrement
% -> remainder
+= -> 
-=
:*=
/=
typeof

todo --comparison operators--
'ojo todos los comparadores devuelven true/false --> borrar esto cuando esté asimilado.
==
=== [strict]
:!=
:!== [strict]
>
>=
<
<=


todo --escape chracters--
\"
\'
\\
\n
\r
\t
\b
\f

todo --postfix/prefix increment
++i -> prefix increment
i++ -> postfix increment
--i -> prefix decrement
i-- -> postfix decrement

todo --logical operators--
&&
||

¡ --ES6--

todo --use strict--
"use strict"

todo --destructuring assignment
const {key1,key2} = var
todo --template literals--
${}
`` -> back ticks


todo --Promise()--
const makeServerRequest = new Promise((resolve,reject) =>{
    if(condition){
        resolve("Promise fulfilled");
    }else{
        reject("Promise rejected");
    }
  
});

makeServerRequest.then(result => {
  console.log(result);
});

ServerRequest.catch(error =>{
  console.log(error);
})

//estados de una promesa
pending
fulfilled()
rejected()

todo --import/export--
//file.js both in the same directory "./"
export {function1,function2};
import {function1,function2} from './index.js';
import * as myObject from './index.js';
//default fallback
export default function(){}
import variableName from "./index.js";

todo --definición de funciones--  
function myFunction(){}
let/var/const = function(a,b){};
x = Function()
//arrow functions
const x = () => {}
const x = () => "value"
const x = item => item * 2;
const x = (item1, item2) => item1 * item2;
//arrow function + object property shorthand
const x = (item1, item2) => ({item1 , item2}); 

todo --spread operator--
...

todo --rest parameter--
...

todo --static reference/static object
let
const
Object.freeze()
let 
"use strict"
...
// destructuring assignment
const {key1,key2} = var
// template literals
${}
`` ->template string
./ 
export
import
get
set

todo --Passing object as a function parameter--
//setup
const stats = {max: 56.78, min: -0.75};
//def normal
const half = (stats) => (stats.max + stats.min) / 2.0; 
//definition using destructuring assignment
const half = (stats) =>{
    const{max,min} = stats;
    return (max + min) / 2.0; 
} 
//definition reduced (no entire object)
const half = ({max,min}) => (max + min) / 2.0; 
}
//use
console.log(half(stats));


//normal
const getMousePosition = (x,y) => ({x: x, y: y});
//object property shorthand
const getMousePosition = (x, y) => ({x , y});

¡ --regular expressions--
match()
test()
|
/regex/i
/regex/g
/./
[x-y]
[^regex]
/x+/
/x*/
/x?/
\W
\w
\d
\D
\s
\S
{min,max}
{min,}
{exact}
(?=...)
(?!...)
(|)
()/1
/^()()$/
replace(regex,"string")
"string".replace(/(\w+)\s(\w+)/,"$2 $1"); 

¡---04---debuggin¡
console.log()
console.clear()
typeof()

todo --falsy values--
//evalúan a false
false
0
""
NaN
undefined
null

¡--05Data structure--¡

todo --arrays--
//array properties
length
//array methods
push()
unshift()
pop()
shift()
splice(arg1,arg2)
slice(arg1,arg2)
indexOf()
//spread operator
[...arr]
//array methods
every()

todo --object attribute adding
//1
object.property = 'value';
//2
object['property'] = 'value';
//3
let variable = 'property name';
object[variable] = 'value';

todo -- delete property
delete object.prperty;

todo- property checking
//method
hasOwnProperty(propertyName); //true/false
//keyword
in
? 'propertyName' in objectName //true/false

todo --iterate over an object keys
for (let variableName in objectName){}
//eg (borrar)
for (let user in users) {console.log(user);}

todo --methods
Object.keys()


*==fMAP========================================================-->
?==iSINTAXIS===================================================-->
?==fSINTAXIS===================================================-->
todo==iTeoría==================================================-->
* 1. Se puede declarar más de una variable en la primera casilla de un for()
//en este caso habría que declararla con var, para que el ámbito salga del bucle y
//se pueda usar luego para devolver el string
function reverseString(str) {
  for (var reversedStr = "", i = str.length - 1; i >= 0; i--) {
    reversedStr += str[i];
  }
  return reversedStr;
}
*2. Análisis de una bonita función
  * 1. Se pueden separar en líneas distintas los métodos para darle más claridad
  * 2. Hay que ponerle las comillas a split("") y a join("") para que lo hagan caracter a caracter.
  * 3. El str pasa a ser array y de nuevo un string.
  * 4. Nunca se muta el string, va cambiando el objeto asociado.
function reverseString(str) {
  return str
    .split("")
    .reverse()
    .join("");
}

*3 tail recursion vs head recursion
todo Head recursión más simple
function recsum(x){
  if (x === 1){
    return 1;
  }else{
    return x + recsum(x - 1);
  }
}
¿Qué hace el intérprete?

recsum(3);
3 + recsum(2);
3 + 2 + recsum(1);
3 + 2 + 1 = 6;
Hasta que no se han ejecutado todas las veces la función no se suman los resultado

todo tail recursion
function tailrecsum(x, total = 0){
  if (x === 0){
    return total;
  }else{
    return tailrecsum(x-1, total + x);
  }
}
Interprete si tailrecsum(3) == tailrecsum(3,0)
tailrecsum(2, 3)
tailrecsum(1, 5)
tailrecsum(0, 5);-> 5
En este caso en cada paso se va calculando el resultado, de tal manera que en el último
ya sale. Implica menos operaciones y es más eficiente.

*4 new Array(x) se puede crear un array usando el constructor
new Array(x); siendo x el tamaño del array
* 5 reduce() ejecuta una función reductora que le pasamos como argumento sobre cada elto del array y devuelve un único valor



todo==fTeoría==================================================-->
!=iSNIPPETS===================================================-->
* 1. Un programa que recibe un string y devuelve el inverso
todo solución Edu 
function reverseString(str) {
  console.log(str);
  let long = str.length;
  console.log(long);
  let arr = [];
  let arrReversed = [];
  for (let i = 0; i < long; i++){
    arr.unshift(str[i]);
  }
  str = "";
  console.log(arr);
  for (let i = 0; i < long; i++){
    str += arr[i];
  }
  console.log(str);
  return str;
}

reverseString("hello");

todo solucion edu2
function reverseString(str) {
  let strCopy = str;
  str ="";
  for (let i = strCopy.length-1; i >=0; i--){
    str += strCopy[i];
    console.log(str);
  }
  return str;
}

reverseString("hello");

¡solución campera

function reverseString(str) {
  return str
    .split("")
    .reverse()
    .join("");
}

* 2. Una función que devuelve el factorial de un número que se le pasa por parámetro
todo solución edu
  function factorialize(num) {
  if(num <= 0){
    return 1;
  }else{
    return factorialize(num-1)*(num);
  }
}
todo camp 1
//1)inicializa y declara la variable  en el for
//2)Hace un for() invertido, empieza por num y llega hasta 1 con > 0
//3)Utiliza un *= para ir multiplicando sucesivamente
function factorialize(num) {
  for (var product = 1; num > 0; num--) {
    product *= num;
  }
  return product;
}

todo camp2
//1) Igual que mi solución pero el caso base es igual estricto a cero
function factorialize(num) {
  if (num === 0) {
    return 1;
  }
  return num * factorialize(num - 1);
}

todo camp3
//utiliza tail recursion en lugar de head recursion
function factorialize(num, factorial = 1) {
  if (num == 0) {
    return factorial;
  } else {
    return factorialize(num - 1, factorial * num);
  }
}

Paso de analizarlo por el momento

* 3 Una función que devuelva el tamaño del string más largo encontrado.
todo solución edu
function findLongestWordLength(str) {
  let word = "";
  let max = 0;
  let result = 0;
  for(let i = 0; i < str.length; i++){
    if(/\s/.test(str[i])){
      word = "";
      console.log('max ' + max);
    }else{
      word += str[i];
      max = word.length;
      if(max > result){
        result = max;
      }
    }
    

  }
  return result;
}
todo solución camp 
function findLongestWordLength(str) {
  var words = str.split(' ');
  var maxLength = 0;

  for (var i = 0; i < words.length; i++) {
    if (words[i].length > maxLength) {
      maxLength = words[i].length;
    }
  }

  return maxLength;
}

!=fSNIPPETS===================================================-->